## Eureka

### 服务治理

主要用来实现各个微服务实例的自动注册与发现。随着系统功能的复杂和微服务实例的增多，静态配置会变得越来越难以维护。随着业务的发展，集群的位置、规模、服务的命名等都有可能发生变化，静态配置极易发生命名错误或者是命名冲突等问题。服务治理主要围绕服务的注册与发现来完成对微服务的自动化管理。

##### 服务注册：	

在服务治理框架中，通常都有一个注册中心，每个服务向注册中心登记自己提供的服务，将主机、端口号、版本号、通信协议等信息告知注册中心，注册中心按服务名分类管理。服务注册中心还需要以心跳的方式去监测清单中的服务是否可用，若不可用则从服务列表中删除。

##### 服务发现：

在微服务框架中，服务间的调用不再是通过指定实例的地址来实现，而是通过向服务名发起请求来实现。服务调用方在调用提供方的接口时，并不知道具体服务实例的位置，因此调用放需要先向注册中心咨询服务，获取所有服务的实例清单，然后再访问具体的服务实例。调用方在拿到服务列表之后，会以某种负载均衡方式从调用的服务中选择一台来进行服务调用，称为客户端负载均衡。

Eureka服务端，也称为注册中心。支持高可用方案，Eureka server的高可用就是将自己作为服务向其它注册中心注册自己。这样就会形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。	

Eureka客户端，主要用来处理服务的注册与发现。客户端服务通过注解与参数配置的方式，嵌在客户端应用代码中，在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性的发送心跳来更新它的服务租约。同时，从服务端查询当前注册的服务信息并把他们缓存在本地，然后周期性的刷新服务的状态。

![](D:\books\Import\java_base\assets\spring\cloud\eureka.png)

##### 服务提供者

- ###### 服务注册

服务提供者在启动时候会通过发送rest请求的方式将自己注册到Eureka server上，同时带上自身的一些元数据信息。Eureka Server在收到请求后，将元信息存储在一个双层map中，其中第一次的key是服务名，第二层的key是具体服务的实例名。

- ###### 服务同步

当两个服务提供者分别注册到不同的服务注册中心时，即他们的信息分别被两个服务注册中心维护。由于两个服务注册中心互相注册为服务，当服务提供发送注册请求到一个服务注册中心时，她会把该请求转发给集群中相连的其它注册中心，从而实现注册中心之间的服务同步，通过服务同步，两个服务提供者的服务信息就可以通过这两台服务中心的任意一台获取到。

- ###### 服务续约

在注册完服务之后，服务的提供者会维护一个“心跳”用来持续告诉Eureka server 自己的状态，以防止Eureka server的‘’剔除任务‘’将改服务实例从服务列表中剔除出去。该操作称为服务续约。

##### 服务消费者

- 服务获取

服务消费方启动之后，他会发送一个rest请求到注册中心，来获取服务提供者的服务清单。为了性能考虑，Eureka server 会维护一个只读的服务清单来返回给客户端，同时该缓存清单每隔30s会更新一次。

- 服务调用

服务消费方在获取清单之后，通过服务名可以获取到具体提供服务发实例名和元数据信息。因为有这些元数据信息，客户端可以根据自己需要决定具体调用哪一个实例。在ribbon客户端负载均衡中，会默认采用轮询的方式。

对于服务的选择，Eureka 中有region和zone的概念，一个region可以包含多个zone，每个服务的客户端需要被注册到一个zone中。在进行服务调用的时候，优先访问同处一个zone中的服务提供方，若访问不到，在访问其它zone。

- 服务下线

避免服务消费者访问到关闭的实例。在客户端程序中，当服务实例进行正常关闭时，会发送一个下线的rest请求到Eureka server。服务端在接受请求后，将该服务状态置为下线，并把该下线时间传播出去。

##### 服务注册中心

- 失效剔除

服务非正常下线，由于网络故障、内存溢出等原因导致服务不可用，而注册中心没有收到下线通知的情况下，为了将不可用的服务从服务清单中清除出去，Eureka server 在启动的时候会创建一个定时任务。默认每隔一段时间(60s)将当前清单中超时(90s)的没有续约的服务清除

- 自我保护

Eureka 在运行期间会统计心跳失败比例在15分钟内是否低于85%，如果出现低于的情况，Eureka server会把当前的实例注册信息保护起来，让这些实例不会过期。在这期间客户端很容易拿到不可用的服务实例。所以客户端必须要有容错机制，如请求重传和断路器等。