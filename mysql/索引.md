# 索引定义

索引（Index）是帮助MySQL高效获取数据的数据结构。索引的本质：索引是数据结构。

优点：可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；

缺点：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间是数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；

# 索引的分类

### **哈希索引：**

​		哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。

​		innoDB支持的hash索引是自适应的，innoDB会根据表的使用情况自动的生成hash索引，不能人为干预在表中生成哈希索引。

### **全文索引**:

​		FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：

```mysql
//创建表的时候添加FULLTEXT索引
CTREATE TABLE my_table(
    id INT(10) PRIMARY KEY,
    name VARCHAR(10) NOT NULL,
    my_text TEXT,
    FULLTEXT(my_text)
)ENGINE=MyISAM DEFAULT CHARSET=utf8;

//创建表以后，在需要的时候添加FULLTEXT索引
ALTER TABLE my_table ADD FULLTEXT INDEX ft_index(column_name);
```

```mysql
SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
```

### **B+Tree索引**

#### **BTree索引**

BTree是平衡搜索多叉树，设树的度为2d（d>1），高度为h，那么BTree要满足以一下条件：

    每个叶子结点的高度一样，等于h；
    每个非叶子结点由n-1个key和n个指针point组成，其中d<=n<=2d,key和point相互间隔，结点两端一定是key；
    叶子结点指针都为null；
    非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；
在BTree的结构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。

#### B+Tree索引

B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：

    B+Tree中的非叶子结点不存储数据，只存储键值；
    B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；
    B+Tree的每个非叶子节点由n个键值key和n个指针point组成；

![img](D:\books\Import\java_base\assets\mysql\B+tree.jpg)

**聚集索引（clustered index）**就是按照每张表的**主键**构造一颗B+树，同时叶子节点中存放的是整张表的行记录数据。聚集索引的叶子节点也称为数据页，每个数据页都通过一个双向列表进行连接。聚集索引表中的数据也是索引的一部分。

​		每张表只能有一个聚集索引，因为实际的数据页只能按照一颗B+树进行排序。由于数据是按顺序存储的，聚集索引能够很快的根据范围值进行查找。

**非聚集索引，也叫辅助索引**。叶子节点并不包含行记录的全部数据，叶子节点除了包含键值以外，每个叶子节点中的索引行还包括了一个书签。该书签就是相应行数据的聚集索引的键。

辅助索引并不影响数据在聚集索引中的组织，因此每张表的辅助索引可以有多个。当通过辅助索引来获取数据时，InnoDB存储引擎会遍历辅助索引并找到叶子节点的指针来获得指向主键索引的主键，然后在通过主键索引来找到一个完整的行记录。

![](D:\books\Import\java_base\assets\mysql\pk index.jpg)

![](D:\books\Import\java_base\assets\mysql\unpk index.jpg)

# 索引的类型

常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引

1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值；

```mysql
ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')；
```

2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值

```mysql
ALTER TABLE 'table_name' ADD UNIQUE index_name('col')；
```

3、普通索引：用表中的普通列构建的索引，没有任何限制

```mysql
ALTER TABLE 'table_name' ADD INDEX index_name('col')；
```

4、全文索引：用大文本对象的列构建的索引（下一部分会讲解）

```mysql
ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col')；
```

5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值

```mysql
ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；
```

遵循“**最左前缀**”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。

*在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引

```mysql
ALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2（3))；
```

表示使用col1的前4个字符和col2的前3个字符作为索引

## Cardinality

并不是所有出现在where条件中的字段都应该加索引，一般的经验是，在访问表中很少一部分数据时使用B+树才有意义。对于性别、地区、月份等他们的取值范围很小，成为**低选择性**。相反，如果某个字段的取值范围很广，几乎没有重复，即属于**高选择性**。对于搞选择性的字段使用B+树索引是合适的，如姓名字段。

## mysql规范

### 数据库字段设计规范

##### 1.优先选择符合存储需要的最小的数据类型。

列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差

- 将字符串转换成数字类型存储，如：将IP地址转换成整形数据。mysql提供了两个方法来处理ip地址：inet_aton 把ip转为无符号整型(4-8位)，inet_ntoa 把整型的ip转为地址。
- 对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储。无符号相对于有符号可以多出一倍的存储空间

##### **2.避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据**

- 建议把BLOB或是TEXT列分离到单独的扩展表中
- TEXT或BLOB类型只能使用前缀索引

##### **3.避免使用ENUM类型**

- 修改ENUM值需要使用ALTER语句
- ENUM类型的ORDER BY操作效率低，需要额外操作
- 禁止使用数值作为ENUM的枚举值

##### **4.尽可能把所有列定义为NOT**  NULL

- 索引列需要额外的空间来保存，所以要占用更多的空间；
- 进行比较和计算时要对值做特别的处理

##### **5.使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间**

##### **6.同财务相关的金额类数据必须使用decimal类型**

### 索引规范

##### 1.索引列选择

- 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列，Cardinality值高的
- 包含在ORDER BY、GROUP BY、DISTINCT中的字段
- 并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好
- 多表join的关联列

##### 2.索引列顺序选择

- 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；
- 尽量把字段长度小的列放在联合索引的最左侧（字段长度越小，一页能存储的数据量越大，IO性能也就越好）；
- 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。

##### 3.关于覆盖索引

对于频繁的查询优先考虑使用覆盖索引（就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引）。

- 避免Innodb表进行索引的二次查询

Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。

- 可以把随机IO变成顺序IO加快查询效率

由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。

### 4.关于查询优化

##### **1.使用预编译语句进行数据库操作**

##### 2.避免索引失效

1. 避免数据类型的隐式转换
2. WHERE从句中禁止对列进行函数转换和计算
3. 避免使用双%号的查询条件
4. 一个SQL只能利用到复合索引中的一列进行范围查询。有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧
5. 使用left join或 not exists来优化not in操作
6. 对应同一列进行or判断时，使用in代替or

##### 3.**禁止使用SELECT \* 必须使用SELECT <字段列表> 查询**

- 消耗更多的CPU和IO以网络带宽资源
- 无法使用覆盖索引
- 可减少表结构变更带来的影响

##### 4.**避免使用子查询，可以把子查询优化为join操作**

通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。

子查询性能差的原因：

- **子查询的结果集无法使用索引**，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响；
- 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；
- 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。

##### 5.**禁止使用order by rand 进行随机排序**

会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。

推荐在程序中获取一个随机值，然后从数据库中获取数据的方式

##### 6.**对于大表使用pt-online-schema-change修改表结构**

- 避免大表修改产生的主从延迟
- 避免在对表字段进行修改时进行锁表

对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。

把原来一个DDL操作，分解成多个小的批次进行。