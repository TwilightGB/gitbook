#  事务的基本要素（ACID）:

1.**原子性**（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。
2、**一致性**（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
3、**隔离性**（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。
4、**持久性**（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚

# 数据库隔离级别

**读未提交（RU）**，**脏读**是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了。

**读提交（RC）**，**不可重复读**事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了

**可重复读（RR）**，**幻读**事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了

**序列化（Serializable）**，事务“串行化顺序执行”，也就是一个一个排队执行。

# mysql锁
InnoDB与MyISAM的最大不同有两点：**一是支持事务（TRANSACTION）**；**二是采用了行级锁**

MySQL这3种锁的特性可大致归纳如下。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

## 1.行锁 
InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
**共享锁（S）**：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
**排他锁（X)**：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

## 2.表锁
**意向共享锁（IS）：**事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
**意向排他锁（IX）：**事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

1.对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
2.对于普通SELECT语句，InnoDB不会加任何锁；
3.事务可以通过以下语句显示给记录集加共享锁或排他锁。
	共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
	排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。
注意：	
	在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。
	如果是使用相同的索引键，是会出现锁冲突的
	当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行
	
	
**间隙锁：**当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！

Select * from  emp where empid > 100 for update;
作用：为了防止幻读（如果不用间隙锁，则如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读）

## 乐观锁与悲观锁

**悲观锁：**它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。依靠数据库提供的锁机制

**乐观锁：**乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

两种实现：
1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式.
2.在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。


