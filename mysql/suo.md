## mysql锁
MySQL这3种锁的特性可大致归纳如下。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

### 1.行锁 
InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
**共享锁（S）**：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
**排他锁（X)**：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

### 2.表锁
**意向共享锁（IS）：**事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
**意向排他锁（IX）：**事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

1.对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
2.对于普通SELECT语句，InnoDB不会加任何锁；
3.事务可以通过以下语句显示给记录集加共享锁或排他锁。
	共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
	排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。
注意：	
	在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。
	如果是使用相同的索引键，是会出现锁冲突的
	当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行
	
	
**间隙锁：**当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！

Select * from  emp where empid > 100 for update;
作用：为了防止幻读（如果不用间隙锁，则如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读）

### 乐观锁与悲观锁

**悲观锁：**它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。依靠数据库提供的锁机制

**乐观锁：**乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

两种实现：
1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式.
2.在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。


