## InnoDB特点

InnoDB存储引擎支持事物，行级锁，外键。支持非锁定读，即默认读取操作不会产生锁。

InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了sql标准的四种隔离级别，默认为RR。同时使用一种next-key locking的策略来避免幻读。此外，还提供了插入缓冲、二次写，自适应hash索引、预读等高性能和高可用性的功能。

## 数据库三范式

第一范式（1NF）：确保每一列的原子性【列不可分】

第二范式:非键字段必须依赖于键字段【除了主键以外的其它列，都依赖与该主键】

第三范式：除了主键以外的其它列都不传递依赖于主键列}

# 事务的基本要素（ACID）

1.**原子性**（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。
2、**一致性**（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
3、**隔离性**（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。
4、**持久性**（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚

# 事物并发带来的问题

**脏读（Dirty Reads）**：是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了。

**不可重复读（Non-Repeatable Reads）**：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了。

**幻读（Phantom Reads）**：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了。

“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本上可分为以下两种。

- 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。
- 另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。

一致性读，又称为**快照读**。使用的是MVCC机制读取undo中的已经提交的数据。所以它的读取是非阻塞的。一致性读肯定是读取在某个时间点已经提交了的数据，**有个特例：本事务中修改的数据，即使未提交的数据也可以在本事务的后面部分读取到。**

- **一致性读**是指普通的select语句，不带 for update, in share mode 等等子句。使用的是**undo**中的提交的数据，**不需要使用锁**(MDL除外)。
- **当前读**，是指update, delete, select for update, select in share mode等等语句进行的读，它们读取的是数据库中的**最新的数据**，并且会**锁住读取的行和gap**(RR隔离时)。如果不能获得锁，则会一直等待，直到获得或者超时。

| 隔离级别                     | 数据一致性                               | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---------------------------------------- | ---- | ---------- | ---- |
| 未提交读（Read uncommitted） | 最低级别，只能保证不读取物理上损坏的数据 | 是   | 是         | 是   |
| 已提交度（Read committed）   | 语句级                                   | 否   | 是         | 是   |
| 可重复读（Repeatable read）  | 事务级                                   | 否   | 否         | 是   |
| 可序列化（Serializable）     | 最高级别，事务级                         | 否   | 否         | 否   |

# 数据库隔离级别

**读未提交（RU）**：一个事务可以读到另一个事务未提交的数据！

**读提交（RC）**：一个事务可以读到另一个事务已提交的数据!

**可重复读（RR）**:加入间隙锁，一定程度上避免了幻读的产生！

**序列化（Serializable）**：串行化，该级别下读写串行化，且所有的select语句后都自动加上lock in share mode，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。

# mysql锁

InnoDB与MyISAM的最大不同有两点：**一是支持事务（TRANSACTION）**；**二是采用了行级锁**

MySQL这3种锁的特性可大致归纳如下。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。（利用了Next-Key Locks，也可以理解为是用了行锁+间隙锁来实现锁表的操作）
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

## 1.行级锁

InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。（只针对于RR和Serializable，如果隔离级别为RU和RC，无论条件列上是否有索引，都不会锁表，只锁行！）
**共享锁（S）**：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

```
SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
```

**排他锁（X)**：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

```
SELECT * FROM table_name WHERE ... FOR UPDATE
```

## 2.表锁(RR,Serializable)

**意向共享锁（IS）：**事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
**意向排他锁（IX）：**事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

**意向锁目的：**

​		假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁。那么此时事务T2要进行LOCK TABLE … WRITE的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。

**对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
对于普通SELECT语句，InnoDB不会加任何锁；**

注意：	

- 意向锁是InnoDB自动加的，不需用户干预。
- 在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。
- 如果是使用相同的索引键，是会出现锁冲突的
- 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
- 使用行锁还是表锁，跟mysql执行计划有关。

## **3.间隙锁**(RR,Serializable)

​		当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（**Next-Key锁**）。特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！

在可重复读（RR）隔离级别下，如果索引是唯一的，且查找也是唯一的，则也不用间隙锁，否则就用间隙锁。

Select * from  emp where empid > 100 for update;
作用：

- 为了防止幻读（如果不用间隙锁，则如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读）
- 另外一方面，是为了满足其恢复和复制的需要。MySQL的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。

**mysql的恢复与复制**

​	MySQL通过BINLOG执行成功的INSERT、UPDATE、DELETE等更新数据的SQL语句，并由此实现MySQL数据库的恢复和主从复制。MySQL的恢复机制（复制其实就是在Slave Mysql不断做基于BINLOG的恢复）有以下特点：

- 一是MySQL的恢复是SQL语句级的，也就是重新执行BINLOG中的SQL语句。这与Oracle数据库不同，Oracle是基于数据库文件块的。
- 二是MySQL的Binlog是按照事务提交的先后顺序记录的，恢复也是按这个顺序进行的。这点也与Oralce不同，Oracle是按照系统更新号（System Change Number，SCN）来恢复数据的，每个事务开始时，Oracle都会分配一个全局唯一的SCN，SCN的顺序与事务开始的时间顺序是一致的。

```
insert  into target_tab select * from source_tab where ...，create  table new_tab ...select ... From  source_tab where ..
```

​		对于(CTAS)这种SQL语句，用户并没有对source_tab做任何更新操作，但InnoDB却给source_tab加了共享锁，并没有使用多版本数据一致性读技术。

​		INSERT...SELECT...和 CREATE TABLE...SELECT...语句，可能会阻止对源表的并发更新，造成对源表锁的等待。如果查询比较复杂的话，会造成严重的性能问题，我们在应用中应尽量避免使用。实际上，MySQL将这种SQL叫作不确定（non-deterministic）的SQL，不推荐使用。

## 4.乐观锁与悲观锁

**悲观锁：**它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。依靠数据库提供的锁机制

**乐观锁：**乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

两种实现：
1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式.
2.在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

# 使用表锁场景

对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。

- 第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。
- 第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。

在InnoDB下，使用表锁要注意以下两点。
      1. 使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层: MySQL Server负责的，仅当autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。
	2.在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。正确的方式见如下语句.

例如，如果需要写表t1并从表t读，可以按如下做：
SET AUTOCOMMIT=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
[do something with tables t1 and t2 here];
COMMIT;
UNLOCK TABLES;

# 死锁

两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。

发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。

避免死锁方法：

1. 如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。
2. 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录。
3. 在事务中，如果要更新记录，应该直接申请足够级别的锁即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。
4. 在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT...FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。
5. 当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT...FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第3个线程又来申请排他锁，也会出现死锁。
   对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。